There are two control "knobs" for the user: the mouse and the keyboard. 

For mouse left-click, the active tool handles the click. For scrolling,
the canvas assumes control and simply scrolls. For right-clicking, we need
to bring up a context menu, which will depend on the active tool and the
current selection. For middle-click, there's no defined behavior yet. 
Left clicks must also check for modifiers, but this hasn't been implemented
yet. 

For the keyboard, things are slightly more involved. Users typically want
to customize their keyboard shortcuts to something that suits them. This
means we need a lot of configuration. We'll just need to have a way to 
bind keys to different actions. 

--------------------------
Adding tools and actions
--------------------------
The Context handles button presses and key presses from the DrawingEventBox,
and actions include changing the tool being used. Because key accelerators
rarely require input parameters, specific actions are created for changing
the tool, and these actions are generated by the KeyAccelMap upon keypresses.
This way, we only need to send an ActionType Enum from KeyAccelMap instead of a
ready-made action. 

All actions are created through the ActionFactory object. This takes an ActionType
enum, optionally with parameters for lines, points, etc (drawing stuff), and 
it returns an Action shared_ptr. All Actions are passed to the ActionStack via 
the Workspace object, so any classes under Workspace (ObjectTree, SpiceData, Canvas,
KeyAccel, Schematic) must emit a new_action() signal, and the Workspace connects to
it. 

When an Action is pushed onto the ActionStack, it is executed by running execute().
When an undo occurs, we run unexecute(). The Action needs to have everything required
in order to complete the execute() method without any further input, and this is the
role of the ActionFactory, which keeps smart pointers to most major objects.

Unlike key accelerators, Tools return fully-formed Actions when their on_click or 
on_key_press callbacks are called. If no Action is required, then a nullptr is 
returned instead. 

To create new actions and features, consider the following:
    1. Do the objects involved in this feature exist? (e.g. Component classes for drawables)
    2. Do the necessary classes know how to handle this feature? (e.g. ObjectTree having
        a place for a new type of component)
    3. What does an Action need in order to invoke things associated with the feature?
        (e.g. add to the ObjectTree requires access to ObjectTree)
    4. What information does an object creating the Action need to supply? (e.g. 
        ComponentParameters)
    5. Who creates the Action and how does it get to the ActionStack?
    6. When should you create the Action? 

If you can answer these, you're basically done. 

----------------------------
Temporary graphics
----------------------------
Everything that gets drawn is currently either (a) drawn by the View object (grid,
origin) or (b) drawn by being stacked on the ObjectTree. So what about temporary
graphics? For example, selection boxes. These should be temporary objects 
with a limited lifetime; we could add them to the ObjectTree, but that's not so much
for objects that aren't part of the actual model; it should be reserved strictly
for drawing components. 

This is where ViewFeatures comes in. This can include methods such as StartTempRectangle()
and FinishTempRectangle() which simplify the interface and maintain good division of
purpose. 

---------------------------------
Actions and the Object Model 
---------------------------------
Components that have been placed on the schematic are stored in the ObjectTree.
These objects are modified by either (a) accessing the ObjectTree directly, or 
(b) passing actions that can be undone. Sometimes a feature will require both of these.
For example, when moving a component, we only want to overall move action to be 
undoable, so that should be an Action. In between, however, the component is being 
dragged around, and on each on_draw() we need to update its position via the 
ObjectTree. We don't want a bunch of tiny Actions, so we want to mark a component 
to be in the process of being moved. When the final move is completed, an Action 
should be used to finalize the new position in an undoable manner. 

The mark that something should follow the mouse is the "active" property. 

Note:
Don't be afraid to manipulate the ObjectTree directly. The Actions are only there 
so things can be undone. If something doesn't need to be undoable, it doesn't
require an Action. 

When a component is active, you can call functions like move_line_vertex().
This automatically applies to the active object(s) of some type. When we're 
handling a tool, we assume that there is an active element, and we ask the 
ObjectTree to perform some task, like moving a Component. Only when the user 
triggers a callback do we need to initialize an actual Component to be active,
and this we do with an Action. Then when everything is done, we simply unset
the Component's active property. In the unexecute() method for the Action, we
must be careful to store the up-to-date information about the component for any 
redos. 


==========================================
on_draw() holds a reference to the ObjectTree, and only uses it to call ObjectTree::redraw().
The ObjectTree is currently responsible for:
    (a) Adding and removing components 
    (b) Indexing components 
    (c) Storing components
    (d) Providing an interface for accessing components 
There is a toplevel Tree object, an a Tree object for each type of component 
within. These are either primitives (points, lines, rectangles) or components 
(which are made of primitives).



######################
NEW OBJECT MODEL
######################
Make an object model with a parent Object class, Primitive classes (Line, Rect, 
Circle, Text), and a CompositeObject class (made up a Symbol and other CompositeObjects). 
Every Object should be uniquely indexed and should be accessible. Objects should be 
able to be "active" and should have a draw() function which accepts a Cairo::Context. 
All objects must have locations and bounding boxes, and given a coordinate we should 
be able to find different objects which are at or near that location.

Every Object should have a Symbol class which stores drawing information specific to 
that Object (excluding generic non-editable elements like highlights). Symbols should 
have drawing settings including stroke and fill settings. The Symbol should be made 
up of Primitives, Pins, and SymbolAttributes. Pins should also have PinAttributes. 

An Object factory should be used to create Objects based on ObjectParameters classes. 
Objects should also have non-editable and optionally visible elements such as vertex 
handlers. Objects should have optional Text which can print the index, name, etc of 
the Object, and the Text should be moveable by itself, while also moving with the Object.

A Wire class should exist which allows addition to a line, and only orthogonal 
('ortho') lines are allowed. The ortho mode should have two options, one for 
each of the two ortho paths that exist between two points. The Wire class should 
be able to connect nodes of Objects. Moving the wire should not break the connections. 
Moving the wire should also maintain orthogonality, and should not create awkward 
overhangs around corners. Vertices which are redundent should be eliminated automatically.

#################
#### PARSING ####
#################
GTKSpice symbol files can be custom. We should also support importing
from LTSpice (.asy files).

For using Flex and Bison (instead of FlexC++ and BisonC++ like I did previously) check out this
link:
    https://aquamentus.com/flex_bison.html
I think I'll stick to the nicer C++ utilities; FlexC++ manual is found here:
	https://fbb-git.gitlab.io/flexcpp/manual/flexc++01.html
For bisonc++:
	https://fbb-git.gitlab.io/bisoncpp/manual/bisonc++.html
Both also have good man pages.



Example of an LTSpice Schematic:
/******* DRAFT1.ASC *******/
  Version 4
  SHEET 1 880 680
  SYMBOL res 96 64 R0
  SYMATTR InstName R1
  SYMBOL res 208 64 R90
  WINDOW 0 0 56 VBottom 2
  WINDOW 3 32 56 VTop 2
  SYMATTR InstName R2
  SYMBOL res 288 64 R90
  WINDOW 0 0 56 VBottom 2
  WINDOW 3 32 56 VTop 2
  SYMATTR InstName R3
  SYMBOL res 352 192 R180
  WINDOW 0 36 76 Left 2
  WINDOW 3 36 40 Left 2
  SYMATTR InstName R4
/**************************/

SHEET means the sheet we're on, SYMBOL is a component symbol, SYMATTR is a symbol attribute,
WINDOW is an attribute window showing some attribute as text. When a value is added to a symbol,
a SYMATTR is added to the schematic. When no components are on the schematic, only Version and
SHEET are in the file. When one resistor is added, we get a SYMBOL and SYMATTR.

When wires are added, we get a WIRE for each segment. When a resistor is rotated, we get 
a WINDOW with VBottom alignment and a WINDOW with VTop alignment for the attribute windows
on that resistor (this just pushes the text around). These appear after the SYMBOL. 


///////////////////////////////////


LTSpice .asy File Standard
---------------------------------
 - Header
	Version <x>			where x is an integer
	SymbolType <XXXX>	where XXXX is either BLOCK or CELL
 - Body
	Geometry (Order: Line, Rectangle, Circle, Arc, Text)
	Attribute Window
	Symbol Attribute
	Pin
	Pin Attribute
	Pin 
	Pin Attribute 
	...
	
=========================================

SymbolType is either:
	BLOCK	Another page in a hierarchical schematic (should have no attributes?)
	CELL	A standalone component with attributes
	
An Attribute Window is text added to the symbol which shows the value of an attribute.

------------------------------
GEOMETRY can be one of the following:
	LINE <Normal> <x1 y1 x2 y2> [linestyle]
	RECTANGLE <Normal> <x1 y1 x2 y2> [linestyle]
	CIRCLE <Normal> <x1 y1 x2 y2> [linestyle]
	ARC <Normal> <x1 y1 x2 y2 x3 y3 x4 y4> [linestyle]
	TEXT <x1 y1> <Justify> <size> <text string>

NOTE: Lines are point-point, rectangles are corner-corner, circles are also 
corner-corner! Ellipses are supported. For arcs, it is corner-corner-startangle-endangle 
where the two angle vertices are actual vertices, but their positions relative 
to the arc center are used to determine the angles. 

<linestyle> can be one of the following:
	(None)	Solid line is assumed
	1		Long-dashed line
	2		Short-dashed line
	3		Long-short-dashed line
	4		Long-short-short-dashed line 

<Justify> can be one of the following:
	Left		Left align
	Right		Right align
	Center		Center align
	Top			Top align
	Bottom		Bottom align
	VLeft		Vertical text left align
	VRight		Vertical text right align
	VCenter		Vertical text center align
	VTop		Vertical text top align
	VBottom		Vertical text bottom align 

<size> is an integer, default is 2, although dialog allows decimals

-----------------------------
WINDOW has the following form:
	WINDOW <Attr> <x y> <Just> <Size>

<Attr> is one of the following:
	0		InstName
	1		Type
	38		SpiceModel 
	3		Value
	123		Value2
	39		SpiceLine
	40		SpiceLine2
The other parameters are the same as for text.


-----------------------------
SYMATTR can be one of the following.
	Prefix <STRING>
	SpiceModel <STRING>
	Value <STRING>
	Value2 <STRING>
	SpiceLine <STRING>
	SpiceLine2 <STRING>
	Description <STRING>
	ModelFile <STRING>

------------------------------
PIN has the following form.
	PIN <x1 y1> <JUST> <OFFSET>

<JUST> can be one of the following:
	TOP
	LEFT 
	RIGHT 
	BOTTOM 
	NONE 

<OFFSET> is an integer >= 0

-----------------------------
PINATTR has the following form.
	PINATTR <AttrName> <AttrValue>
	
<AttrName> can be one of the following:
	PinName			<AttrValue> is a string
	SpiceOrder		<AttrValue> is an int >0

========================================
EXAMPLE

/****** TEST.ASY ********/
  Version 4
  SymbolType CELL
  LINE Normal 16 0 16 -16
  LINE Normal 0 32 -16 16 1
  LINE Normal -30 -37 -49 -16 2
  LINE Normal -5 -43 -30 -16 3
  LINE Normal 30 -48 0 -16 4
  RECTANGLE Normal 48 0 32 -16
  CIRCLE Normal 48 48 32 32
  ARC Normal -64 0 -48 16 -51 2 -65 10
  TEXT -106 -32 Top 3 test
  WINDOW 38 12 13 Left 3
  SYMATTR Prefix s
  SYMATTR SpiceModel <SpiceModel>
  PIN 96 32 TOP 5
  PINATTR PinName mypin
  PINATTR SpiceOrder 1
  PIN 64 96 RIGHT 8
  PINATTR PinName otherpin
  PINATTR SpiceOrder 2
/**************************/


///////////////////////////////
Time to handle wires (nets). A -node- is a conceptual connection, which
has a name (a string). From a modelling standpoing, nets don't 
exist. Only nodes exist, and each node is numbered starting with "0" 
(reserved for ground) followed by 1, 2, ... by default, and generally
nodes are named with strings. GtkSpiceObjects maintain a list of nodes 
in SpiceOrder, which means "connecting" two components with wires 
involves (direct method):
I. Initialization of a wire
	a. If this is a new wire (free wire or unconnected pin), give it 
		a new node name, connect the pin to this node
	b. If this wire starts on another node (a wire or connected pin)
		use the existing node name
II. Connection of a wire
	a. If the connection is free, start a new wire after this wire
	b. If the connection is to another node (a wire or connected pin)
		somehow merge the two node names, renaming all connections, 
		finish wire.
	c. If the connection is to an unconnected pin, set the connection 
		for that pin, finish wire.
	d. Optionally finish the wire

From this, we have the following actions required:
	- Creating a new node
	- Connecting a node to a pin
	- Merging two nodes
	- Renaming a node
We cannot simply store node names. If we did, then renaming a node would
become much more difficult (we would have to search all elements for their
pin connections and manually change any that match). Instead, we need to 
have the Schematic own a collection of GtkSpiceNodes, and it shares pointers 
to those nodes with GtkSpiceElements when necessary.

Fortunately, the Schematic also owns the GtkSpiceElements, so connecting is
relatively straightforward, we just need a connect() function:
	connect(Element,Node)
And a merge() function:
	merge(Node, Node)
Which is equivalent to connecting two Nodes. This presents the problem that
we need to now make sure all Elements which are connected to the old Node(s)
have their pointers updated to point to the new Node. 

The following configurations should be considered:
	Element stores connections to Nodes
	Nodes store connections to Elements
	A third party stores this information
The first is appealing for its directness, the second is appealing because
it makes merging nodes straightforward. The last is less appealing. 

== NODES VS WIRES ==
A -Wire- is a drawable which is associated with a single Node. The user 
interacts with Wires, while Nodes are managed by the Schematic. But when a 
Wire starts or ends on an Element's pin, or another Wire, a connection must 
be made. The Wire object can do this, using its own data to call connect(). 
Alternatively, we can simply update the Wire geometry (adding a point for 
mid-wire connections) and we can handle the connect() externally. 



