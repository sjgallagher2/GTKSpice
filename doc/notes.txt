There are two control "knobs" for the user: the mouse and the keyboard. 

For mouse left-click, the active tool handles the click. For scrolling,
the canvas assumes control and simply scrolls. For right-clicking, we need
to bring up a context menu, which will depend on the active tool and the
current selection. For middle-click, there's no defined behavior yet. 
Left clicks must also check for modifiers, but this hasn't been implemented
yet. 

For the keyboard, things are slightly more involved. Users typically want
to customize their keyboard shortcuts to something that suits them. This
means we need a lot of configuration. We'll just need to have a way to 
bind keys to different actions. 

--------------------------
Adding tools and actions
--------------------------
The Context handles button presses and key presses from the DrawingEventBox,
and actions include changing the tool being used. Because key accelerators
rarely require input parameters, specific actions are created for changing
the tool, and these actions are generated by the KeyAccelMap upon keypresses.
This way, we only need to send an ActionType Enum from KeyAccelMap instead of a
ready-made action. 

All actions are created through the ActionFactory object. This takes an ActionType
enum, optionally with parameters for lines, points, etc (drawing stuff), and 
it returns an Action shared_ptr. All Actions are passed to the ActionStack via 
the Workspace object, so any classes under Workspace (ObjectTree, SpiceData, Canvas,
KeyAccel, Schematic) must emit a new_action() signal, and the Workspace connects to
it. 

When an Action is pushed onto the ActionStack, it is executed by running execute().
When an undo occurs, we run unexecute(). The Action needs to have everything required
in order to complete the execute() method without any further input, and this is the
role of the ActionFactory, which keeps smart pointers to most major objects.

Unlike key accelerators, Tools return fully-formed Actions when their on_click or 
on_key_press callbacks are called. If no Action is required, then a nullptr is 
returned instead. 

To create new actions and features, consider the following:
    1. Do the objects involved in this feature exist? (e.g. Component classes for drawables)
    2. Do the necessary classes know how to handle this feature? (e.g. ObjectTree having
        a place for a new type of component)
    3. What does an Action need in order to invoke things associated with the feature?
        (e.g. add to the ObjectTree requires access to ObjectTree)
    4. What information does an object creating the Action need to supply? (e.g. 
        ComponentParameters)
    5. Who creates the Action and how does it get to the ActionStack?

If you can answer these, you're basically done. 

----------------------------
Temporary graphics
----------------------------
Everything that gets drawn is currently either (a) drawn by the View object (grid,
origin) or (b) drawn by being stacked on the ObjectTree. So what about temporary
graphics? For example, selection boxes. These should be temporary objects 
with a limited lifetime; we could add them to the ObjectTree, but that's not so much
for objects that aren't part of the actual model; it should be reserved strictly
for drawing components. 

This is where ViewFeatures comes in. This can include methods such as StartTempRectangle()
and FinishTempRectangle() which simplify the interface and maintain good division of
purpose. 
